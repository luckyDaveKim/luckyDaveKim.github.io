{
    "componentChunkName": "component---src-templates-index-tsx",
    "path": "/3",
    "result": {"data":{"logo":{"childImageSharp":{"gatsbyImageData":{"layout":"fixed","backgroundColor":"#080808","images":{"fallback":{"src":"/static/8a5d1bbceb8374ac91f29d7785527a15/18875/blog-logo.png","srcSet":"/static/8a5d1bbceb8374ac91f29d7785527a15/18875/blog-logo.png 436w","sizes":"436px"},"sources":[{"srcSet":"/static/8a5d1bbceb8374ac91f29d7785527a15/fbb92/blog-logo.webp 436w","type":"image/webp","sizes":"436px"}]},"width":436,"height":108}}},"header":{"childImageSharp":{"gatsbyImageData":{"layout":"fixed","backgroundColor":"#080818","images":{"fallback":{"src":"/static/f55e924eff608d71da37e57b398c587d/b5801/blog-cover.jpg","srcSet":"/static/f55e924eff608d71da37e57b398c587d/b5801/blog-cover.jpg 1440w","sizes":"1440px"},"sources":[{"srcSet":"/static/f55e924eff608d71da37e57b398c587d/8e13d/blog-cover.webp 1440w","type":"image/webp","sizes":"1440px"}]},"width":1440,"height":480}}},"allMarkdownRemark":{"edges":[{"node":{"timeToRead":3,"frontmatter":{"title":"[이펙티브 자바 3] 객체 생성과 파괴 | 생성자에 매개변수가 많다면 빌더를 고려하라","date":"2021-01-05T19:11:02.000Z","tags":["effective_java","java","creating_and_destroying_objects"],"draft":false,"excerpt":"정적 팩토리 메소드와 생성자에서 매개변수가 많아진 경우 효과적으로 처리하는 방법에 대해 알아봅니다.","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/3393fbd2a8b809fdb7a375e261636955/69eac/cover.jpg","srcSet":"/static/3393fbd2a8b809fdb7a375e261636955/706fa/cover.jpg 360w,\n/static/3393fbd2a8b809fdb7a375e261636955/f7872/cover.jpg 720w,\n/static/3393fbd2a8b809fdb7a375e261636955/69eac/cover.jpg 1440w","sizes":"(min-width: 1440px) 1440px, 100vw"},"sources":[{"srcSet":"/static/3393fbd2a8b809fdb7a375e261636955/22e2a/cover.webp 360w,\n/static/3393fbd2a8b809fdb7a375e261636955/4da88/cover.webp 720w,\n/static/3393fbd2a8b809fdb7a375e261636955/31706/cover.webp 1440w","type":"image/webp","sizes":"(min-width: 1440px) 1440px, 100vw"}]},"width":1440,"height":960}}}},"excerpt":"본 내용은 이펙티브 자바 3판(Joshua Bloch…","fields":{"slug":"/development/etc/effective-java/item2-consider-a-builder-when-faced-with-many-constructor-parameters"}}},{"node":{"timeToRead":4,"frontmatter":{"title":"[이펙티브 자바 3] 객체 생성과 파괴 | 생성자 대신 정적 팩터리 메서드를 고려하라","date":"2021-01-05T08:28:47.000Z","tags":["effective_java","java","creating_and_destroying_objects"],"draft":false,"excerpt":"생성자와 정적 팩토리 메소드를 비교 분석하고, 예시를 바탕으로 각각의 장/단점에 대해 알아봅니다.","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/3393fbd2a8b809fdb7a375e261636955/69eac/cover.jpg","srcSet":"/static/3393fbd2a8b809fdb7a375e261636955/706fa/cover.jpg 360w,\n/static/3393fbd2a8b809fdb7a375e261636955/f7872/cover.jpg 720w,\n/static/3393fbd2a8b809fdb7a375e261636955/69eac/cover.jpg 1440w","sizes":"(min-width: 1440px) 1440px, 100vw"},"sources":[{"srcSet":"/static/3393fbd2a8b809fdb7a375e261636955/22e2a/cover.webp 360w,\n/static/3393fbd2a8b809fdb7a375e261636955/4da88/cover.webp 720w,\n/static/3393fbd2a8b809fdb7a375e261636955/31706/cover.webp 1440w","type":"image/webp","sizes":"(min-width: 1440px) 1440px, 100vw"}]},"width":1440,"height":960}}}},"excerpt":"본 내용은 이펙티브 자바 3판(Joshua Bloch…","fields":{"slug":"/development/etc/effective-java/item1-consider-static-factory-methods-instead-of-constructors"}}},{"node":{"timeToRead":5,"frontmatter":{"title":"[LeetCode] #105. Construct Binary Tree from Preorder and Inorder Traversal","date":"2020-12-13T17:33:51.000Z","tags":["leet_code","algorithm","medium_level","java","array","tree","depth_first_search","dfs"],"draft":false,"excerpt":"전위 순회, 중위 순회 값을 바탕으로 이진 트리를 구해봅니다.","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg","srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/8963f/cover.jpg 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/160a8/cover.jpg 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg 1000w","sizes":"(min-width: 1000px) 1000px, 100vw"},"sources":[{"srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/e175a/cover.webp 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/14517/cover.webp 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/7592a/cover.webp 1000w","type":"image/webp","sizes":"(min-width: 1000px) 1000px, 100vw"}]},"width":1440,"height":604.8}}}},"excerpt":"문제 #105. Construct Binary Tree from Preorder and Inorder Traversal Given preorder and inorder traversal of a tree, construct the binary tree…","fields":{"slug":"/algorithm/leetcode/construct-binary-tree-from-preorder-and-inorder-traversal"}}},{"node":{"timeToRead":6,"frontmatter":{"title":"[LeetCode] #102. Binary Tree Level Order Traversal","date":"2020-12-13T06:16:58.000Z","tags":["leet_code","algorithm","medium_level","java","tree","breadth_first_search","bfs"],"draft":false,"excerpt":"주어진 트리의 너비 우선 탐색(BFS)을 통해 레벨별로 묶은 노드의 값을 구해봅니다.","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg","srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/8963f/cover.jpg 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/160a8/cover.jpg 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg 1000w","sizes":"(min-width: 1000px) 1000px, 100vw"},"sources":[{"srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/e175a/cover.webp 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/14517/cover.webp 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/7592a/cover.webp 1000w","type":"image/webp","sizes":"(min-width: 1000px) 1000px, 100vw"}]},"width":1440,"height":604.8}}}},"excerpt":"문제 #102. Binary Tree Level Order Traversal Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to…","fields":{"slug":"/algorithm/leetcode/binary-tree-level-order-traversal"}}},{"node":{"timeToRead":4,"frontmatter":{"title":"[LeetCode] #98. Validate Binary Search Tree","date":"2020-12-10T08:04:21.000Z","tags":["leet_code","algorithm","medium_level","java","tree","depth_first_search","binary_search_tree","bst"],"draft":false,"excerpt":"주어진 트리가 올바른 이진 탐색 트리인지 확인합니다.","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg","srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/8963f/cover.jpg 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/160a8/cover.jpg 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg 1000w","sizes":"(min-width: 1000px) 1000px, 100vw"},"sources":[{"srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/e175a/cover.webp 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/14517/cover.webp 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/7592a/cover.webp 1000w","type":"image/webp","sizes":"(min-width: 1000px) 1000px, 100vw"}]},"width":1440,"height":604.8}}}},"excerpt":"문제 #98. Validate Binary Search Tree Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is…","fields":{"slug":"/algorithm/leetcode/validate-binary-search-tree"}}},{"node":{"timeToRead":4,"frontmatter":{"title":"Java Phantom Reachable, Phantom Reference 란","date":"2020-12-01T05:26:02.000Z","tags":["reference","java","phantom_reference","phantom_reachable","reachable","기술_면접_질문"],"draft":false,"excerpt":"Java의 Phantom Reachable 특징과 Phantom Reference 사용 예시에 대해 알아봅니다.","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#486848","images":{"fallback":{"src":"/static/09ab2179559b89d3ddb241d37db13285/86738/cover.jpg","srcSet":"/static/09ab2179559b89d3ddb241d37db13285/79dfe/cover.jpg 360w,\n/static/09ab2179559b89d3ddb241d37db13285/be09f/cover.jpg 720w,\n/static/09ab2179559b89d3ddb241d37db13285/86738/cover.jpg 1440w","sizes":"(min-width: 1440px) 1440px, 100vw"},"sources":[{"srcSet":"/static/09ab2179559b89d3ddb241d37db13285/46060/cover.webp 360w,\n/static/09ab2179559b89d3ddb241d37db13285/c7e6a/cover.webp 720w,\n/static/09ab2179559b89d3ddb241d37db13285/f94ff/cover.webp 1440w","type":"image/webp","sizes":"(min-width: 1440px) 1440px, 100vw"}]},"width":1440,"height":1000}}}},"excerpt":"개요 이 포스팅에서는 Java의 References 종류 중 Phantom Reference의 사용 예시와 **Phantom reachable**의 특징에 대해 알아보겠습니다. Reference 종류는 왜 나누어져 있는가? Java의 Reference…","fields":{"slug":"/development/back-end/java/phantom-reference-in-java"}}}]}},"pageContext":{"limit":6,"skip":12,"currentPage":3,"numPages":7,"pathPrefix":"/"}},
    "staticQueryHashes": ["1144773313","288898337"]}