{
    "componentChunkName": "component---src-templates-tag-tsx",
    "path": "/tags/java",
    "result": {"data":{"allTagYaml":{"edges":[{"node":{"id":"git","description":"파일의 변경사항을 추적하고 여러 명의 사용자들 간에 해당 파일들의 작업을 조율하기 위한 분산 버전 관리 시스템","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#282828","images":{"fallback":{"src":"/static/ea4bdee544abdc5812226950e35b12fa/b0aab/git-cover.png","srcSet":"/static/ea4bdee544abdc5812226950e35b12fa/e8995/git-cover.png 337w,\n/static/ea4bdee544abdc5812226950e35b12fa/d0735/git-cover.png 675w,\n/static/ea4bdee544abdc5812226950e35b12fa/b0aab/git-cover.png 1349w","sizes":"(min-width: 1349px) 1349px, 100vw"},"sources":[{"srcSet":"/static/ea4bdee544abdc5812226950e35b12fa/8de52/git-cover.webp 337w,\n/static/ea4bdee544abdc5812226950e35b12fa/7c825/git-cover.webp 675w,\n/static/ea4bdee544abdc5812226950e35b12fa/09bf1/git-cover.webp 1349w","type":"image/webp","sizes":"(min-width: 1349px) 1349px, 100vw"}]},"width":1440,"height":710.9266123054115}}}}},{"node":{"id":"github","description":"분산 버전 관리 툴인 Git을 사용하는 프로젝트를 지원하는 웹호스팅 서비스","image":null}},{"node":{"id":"jekyll","description":"개인 프로젝트 혹은 조직 사이트를 위한 간단한 블로그를 생성 할 수 있는 정적 사이트 생성기","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#383838","images":{"fallback":{"src":"/static/e5585869d4ebb4b4a1525840d553350c/4f407/jekyll-cover.png","srcSet":"/static/e5585869d4ebb4b4a1525840d553350c/b80f3/jekyll-cover.png 320w,\n/static/e5585869d4ebb4b4a1525840d553350c/33942/jekyll-cover.png 640w,\n/static/e5585869d4ebb4b4a1525840d553350c/4f407/jekyll-cover.png 1280w","sizes":"(min-width: 1280px) 1280px, 100vw"},"sources":[{"srcSet":"/static/e5585869d4ebb4b4a1525840d553350c/aeec2/jekyll-cover.webp 320w,\n/static/e5585869d4ebb4b4a1525840d553350c/99f93/jekyll-cover.webp 640w,\n/static/e5585869d4ebb4b4a1525840d553350c/b584c/jekyll-cover.webp 1280w","type":"image/webp","sizes":"(min-width: 1280px) 1280px, 100vw"}]},"width":1440,"height":720}}}}}]},"allMarkdownRemark":{"totalCount":18,"edges":[{"node":{"excerpt":"개요 이 포스팅에서는 Java 객체의 직렬화(Serialization)와 직렬화된 정보를 Java 객체로 만드는 역 직렬화(Deserialization…","timeToRead":6,"frontmatter":{"title":"Java 직렬화 (Serialization)와 역 직렬화 (Deserialization) 란","excerpt":"Java 객체의 직렬화(Serialization)와 역 직렬화(Deserialization)의 개념과 사용 예시에 대해 알아봅니다.","tags":["serialization","deserialization","serializable","java","기술_면접_질문"],"date":"2021-01-11T08:43:16.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/a7e90b1e442fd11794e6d54deb3c9896/da6c7/cover.jpg","srcSet":"/static/a7e90b1e442fd11794e6d54deb3c9896/62978/cover.jpg 360w,\n/static/a7e90b1e442fd11794e6d54deb3c9896/85c38/cover.jpg 720w,\n/static/a7e90b1e442fd11794e6d54deb3c9896/da6c7/cover.jpg 1440w","sizes":"(min-width: 1440px) 1440px, 100vw"},"sources":[{"srcSet":"/static/a7e90b1e442fd11794e6d54deb3c9896/e20e0/cover.webp 360w,\n/static/a7e90b1e442fd11794e6d54deb3c9896/a7cae/cover.webp 720w,\n/static/a7e90b1e442fd11794e6d54deb3c9896/c2da5/cover.webp 1440w","type":"image/webp","sizes":"(min-width: 1440px) 1440px, 100vw"}]},"width":1440,"height":964}}}},"fields":{"slug":"/development/back-end/java/serialization-java"}}},{"node":{"excerpt":"본 내용은 이펙티브 자바 3판(Joshua Bloch…","timeToRead":3,"frontmatter":{"title":"[이펙티브 자바 3] 객체 생성과 파괴 | 생성자에 매개변수가 많다면 빌더를 고려하라","excerpt":"정적 팩토리 메소드와 생성자에서 매개변수가 많아진 경우 효과적으로 처리하는 방법에 대해 알아봅니다.","tags":["effective_java","java","creating_and_destroying_objects"],"date":"2021-01-05T19:11:02.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/3393fbd2a8b809fdb7a375e261636955/69eac/cover.jpg","srcSet":"/static/3393fbd2a8b809fdb7a375e261636955/706fa/cover.jpg 360w,\n/static/3393fbd2a8b809fdb7a375e261636955/f7872/cover.jpg 720w,\n/static/3393fbd2a8b809fdb7a375e261636955/69eac/cover.jpg 1440w","sizes":"(min-width: 1440px) 1440px, 100vw"},"sources":[{"srcSet":"/static/3393fbd2a8b809fdb7a375e261636955/22e2a/cover.webp 360w,\n/static/3393fbd2a8b809fdb7a375e261636955/4da88/cover.webp 720w,\n/static/3393fbd2a8b809fdb7a375e261636955/31706/cover.webp 1440w","type":"image/webp","sizes":"(min-width: 1440px) 1440px, 100vw"}]},"width":1440,"height":960}}}},"fields":{"slug":"/development/etc/effective-java/item2-consider-a-builder-when-faced-with-many-constructor-parameters"}}},{"node":{"excerpt":"본 내용은 이펙티브 자바 3판(Joshua Bloch…","timeToRead":4,"frontmatter":{"title":"[이펙티브 자바 3] 객체 생성과 파괴 | 생성자 대신 정적 팩터리 메서드를 고려하라","excerpt":"생성자와 정적 팩토리 메소드를 비교 분석하고, 예시를 바탕으로 각각의 장/단점에 대해 알아봅니다.","tags":["effective_java","java","creating_and_destroying_objects"],"date":"2021-01-05T08:28:47.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/3393fbd2a8b809fdb7a375e261636955/69eac/cover.jpg","srcSet":"/static/3393fbd2a8b809fdb7a375e261636955/706fa/cover.jpg 360w,\n/static/3393fbd2a8b809fdb7a375e261636955/f7872/cover.jpg 720w,\n/static/3393fbd2a8b809fdb7a375e261636955/69eac/cover.jpg 1440w","sizes":"(min-width: 1440px) 1440px, 100vw"},"sources":[{"srcSet":"/static/3393fbd2a8b809fdb7a375e261636955/22e2a/cover.webp 360w,\n/static/3393fbd2a8b809fdb7a375e261636955/4da88/cover.webp 720w,\n/static/3393fbd2a8b809fdb7a375e261636955/31706/cover.webp 1440w","type":"image/webp","sizes":"(min-width: 1440px) 1440px, 100vw"}]},"width":1440,"height":960}}}},"fields":{"slug":"/development/etc/effective-java/item1-consider-static-factory-methods-instead-of-constructors"}}},{"node":{"excerpt":"문제 #105. Construct Binary Tree from Preorder and Inorder Traversal Given preorder and inorder traversal of a tree, construct the binary tree…","timeToRead":5,"frontmatter":{"title":"[LeetCode] #105. Construct Binary Tree from Preorder and Inorder Traversal","excerpt":"전위 순회, 중위 순회 값을 바탕으로 이진 트리를 구해봅니다.","tags":["leet_code","algorithm","medium_level","java","array","tree","depth_first_search","dfs"],"date":"2020-12-13T17:33:51.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg","srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/8963f/cover.jpg 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/160a8/cover.jpg 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg 1000w","sizes":"(min-width: 1000px) 1000px, 100vw"},"sources":[{"srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/e175a/cover.webp 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/14517/cover.webp 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/7592a/cover.webp 1000w","type":"image/webp","sizes":"(min-width: 1000px) 1000px, 100vw"}]},"width":1440,"height":604.8}}}},"fields":{"slug":"/algorithm/leetcode/construct-binary-tree-from-preorder-and-inorder-traversal"}}},{"node":{"excerpt":"문제 #102. Binary Tree Level Order Traversal Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to…","timeToRead":6,"frontmatter":{"title":"[LeetCode] #102. Binary Tree Level Order Traversal","excerpt":"주어진 트리의 너비 우선 탐색(BFS)을 통해 레벨별로 묶은 노드의 값을 구해봅니다.","tags":["leet_code","algorithm","medium_level","java","tree","breadth_first_search","bfs"],"date":"2020-12-13T06:16:58.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg","srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/8963f/cover.jpg 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/160a8/cover.jpg 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg 1000w","sizes":"(min-width: 1000px) 1000px, 100vw"},"sources":[{"srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/e175a/cover.webp 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/14517/cover.webp 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/7592a/cover.webp 1000w","type":"image/webp","sizes":"(min-width: 1000px) 1000px, 100vw"}]},"width":1440,"height":604.8}}}},"fields":{"slug":"/algorithm/leetcode/binary-tree-level-order-traversal"}}},{"node":{"excerpt":"문제 #98. Validate Binary Search Tree Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is…","timeToRead":4,"frontmatter":{"title":"[LeetCode] #98. Validate Binary Search Tree","excerpt":"주어진 트리가 올바른 이진 탐색 트리인지 확인합니다.","tags":["leet_code","algorithm","medium_level","java","tree","depth_first_search","binary_search_tree","bst"],"date":"2020-12-10T08:04:21.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg","srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/8963f/cover.jpg 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/160a8/cover.jpg 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg 1000w","sizes":"(min-width: 1000px) 1000px, 100vw"},"sources":[{"srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/e175a/cover.webp 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/14517/cover.webp 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/7592a/cover.webp 1000w","type":"image/webp","sizes":"(min-width: 1000px) 1000px, 100vw"}]},"width":1440,"height":604.8}}}},"fields":{"slug":"/algorithm/leetcode/validate-binary-search-tree"}}},{"node":{"excerpt":"개요 이 포스팅에서는 Java의 References 종류 중 Phantom Reference의 사용 예시와 **Phantom reachable**의 특징에 대해 알아보겠습니다. Reference 종류는 왜 나누어져 있는가? Java의 Reference…","timeToRead":4,"frontmatter":{"title":"Java Phantom Reachable, Phantom Reference 란","excerpt":"Java의 Phantom Reachable 특징과 Phantom Reference 사용 예시에 대해 알아봅니다.","tags":["reference","java","phantom_reference","phantom_reachable","reachable","기술_면접_질문"],"date":"2020-12-01T05:26:02.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#486848","images":{"fallback":{"src":"/static/09ab2179559b89d3ddb241d37db13285/86738/cover.jpg","srcSet":"/static/09ab2179559b89d3ddb241d37db13285/79dfe/cover.jpg 360w,\n/static/09ab2179559b89d3ddb241d37db13285/be09f/cover.jpg 720w,\n/static/09ab2179559b89d3ddb241d37db13285/86738/cover.jpg 1440w","sizes":"(min-width: 1440px) 1440px, 100vw"},"sources":[{"srcSet":"/static/09ab2179559b89d3ddb241d37db13285/46060/cover.webp 360w,\n/static/09ab2179559b89d3ddb241d37db13285/c7e6a/cover.webp 720w,\n/static/09ab2179559b89d3ddb241d37db13285/f94ff/cover.webp 1440w","type":"image/webp","sizes":"(min-width: 1440px) 1440px, 100vw"}]},"width":1440,"height":1000}}}},"fields":{"slug":"/development/back-end/java/phantom-reference-in-java"}}},{"node":{"excerpt":"개요 이 포스팅에서는 Java의 References 종류 중 Weak Reference의 사용 예시와 **Weakly reachable**의 특징에 대해 알아보겠습니다. Reference 종류는 왜 나누어져 있는가? Java의 Reference…","timeToRead":3,"frontmatter":{"title":"Java Weakly Reachable, Weak Reference 란","excerpt":"Java의 Weakly Reachable 특징과 Weak Reference 사용 예시에 대해 알아봅니다.","tags":["reference","java","weak_reference","weakly_reachable","reachable","기술_면접_질문"],"date":"2020-12-01T04:25:27.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/42af6e28771081cbb76776cb14ad5050/24dd4/cover.jpg","srcSet":"/static/42af6e28771081cbb76776cb14ad5050/6ce48/cover.jpg 175w,\n/static/42af6e28771081cbb76776cb14ad5050/92240/cover.jpg 350w,\n/static/42af6e28771081cbb76776cb14ad5050/24dd4/cover.jpg 700w","sizes":"(min-width: 700px) 700px, 100vw"},"sources":[{"srcSet":"/static/42af6e28771081cbb76776cb14ad5050/32753/cover.webp 175w,\n/static/42af6e28771081cbb76776cb14ad5050/ab163/cover.webp 350w,\n/static/42af6e28771081cbb76776cb14ad5050/c2d65/cover.webp 700w","type":"image/webp","sizes":"(min-width: 700px) 700px, 100vw"}]},"width":1440,"height":703.5428571428571}}}},"fields":{"slug":"/development/back-end/java/weak-reference-in-java"}}},{"node":{"excerpt":"개요 이 포스팅에서는 Java의 References 종류 중 Soft Reference의 사용 예시와 **Softly reachable**의 특징에 대해 알아보겠습니다. Reference 종류는 왜 나누어져 있는가? Java의 Reference…","timeToRead":3,"frontmatter":{"title":"Java Softly Reachable, Soft Reference 란","excerpt":"Java의 Softly Reachable 특징과 Soft Reference 사용 예시에 대해 알아봅니다.","tags":["reference","java","soft_reference","softly_reachable","reachable","기술_면접_질문"],"date":"2020-12-01T03:49:05.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080818","images":{"fallback":{"src":"/static/c7c92b1bd6624c9c1e86afb737ea437f/69eac/cover.jpg","srcSet":"/static/c7c92b1bd6624c9c1e86afb737ea437f/706fa/cover.jpg 360w,\n/static/c7c92b1bd6624c9c1e86afb737ea437f/f7872/cover.jpg 720w,\n/static/c7c92b1bd6624c9c1e86afb737ea437f/69eac/cover.jpg 1440w","sizes":"(min-width: 1440px) 1440px, 100vw"},"sources":[{"srcSet":"/static/c7c92b1bd6624c9c1e86afb737ea437f/22e2a/cover.webp 360w,\n/static/c7c92b1bd6624c9c1e86afb737ea437f/4da88/cover.webp 720w,\n/static/c7c92b1bd6624c9c1e86afb737ea437f/31706/cover.webp 1440w","type":"image/webp","sizes":"(min-width: 1440px) 1440px, 100vw"}]},"width":1440,"height":960}}}},"fields":{"slug":"/development/back-end/java/soft-reference-in-java"}}},{"node":{"excerpt":"개요 이 포스팅에서는 Java의 References 종류 중 Strong Reference의 사용 예시와 Strongly reachable의 특징에 대해 알아보겠습니다. Reference 종류는 왜 나누어져 있는가? Java의 Reference…","timeToRead":2,"frontmatter":{"title":"Java Strongly Reachable, Strong Reference 란","excerpt":"Java의 Strongly Reachable 특징과 Strong Reference 사용 예시에 대해 알아봅니다.","tags":["reference","java","strong_reference","strongly_reachable","reachable","기술_면접_질문"],"date":"2020-12-01T02:19:15.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/073a46ccfdc8b504382098cb7aaf7abf/3d29c/cover.jpg","srcSet":"/static/073a46ccfdc8b504382098cb7aaf7abf/a3faa/cover.jpg 360w,\n/static/073a46ccfdc8b504382098cb7aaf7abf/bac42/cover.jpg 720w,\n/static/073a46ccfdc8b504382098cb7aaf7abf/3d29c/cover.jpg 1440w","sizes":"(min-width: 1440px) 1440px, 100vw"},"sources":[{"srcSet":"/static/073a46ccfdc8b504382098cb7aaf7abf/5ea19/cover.webp 360w,\n/static/073a46ccfdc8b504382098cb7aaf7abf/b39fa/cover.webp 720w,\n/static/073a46ccfdc8b504382098cb7aaf7abf/c0eec/cover.webp 1440w","type":"image/webp","sizes":"(min-width: 1440px) 1440px, 100vw"}]},"width":1440,"height":752}}}},"fields":{"slug":"/development/back-end/java/strong-reference-in-java"}}},{"node":{"excerpt":"개요 이 포스팅에서는 Java의 접근 제어자의 종류에 대해 알아보고, 각 접근제어자별 차이점에 대해 알아보도록 하겠습니다. 접근 제어자(Access Modifier) 란? Java…","timeToRead":6,"frontmatter":{"title":"Java 접근 제어자 (Access Modifier)","excerpt":"Java의 접근 제어자(Access Modifier)의 종류 및 차이에 대해 알아봅니다.","tags":["java","access_modifier","interview"],"date":"2020-11-18T03:50:10.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/76f8fc3f5ed12231fb19c9ed51ac593c/db9be/cover.jpg","srcSet":"/static/76f8fc3f5ed12231fb19c9ed51ac593c/2c0a8/cover.jpg 360w,\n/static/76f8fc3f5ed12231fb19c9ed51ac593c/76181/cover.jpg 720w,\n/static/76f8fc3f5ed12231fb19c9ed51ac593c/db9be/cover.jpg 1440w","sizes":"(min-width: 1440px) 1440px, 100vw"},"sources":[{"srcSet":"/static/76f8fc3f5ed12231fb19c9ed51ac593c/526dd/cover.webp 360w,\n/static/76f8fc3f5ed12231fb19c9ed51ac593c/1554a/cover.webp 720w,\n/static/76f8fc3f5ed12231fb19c9ed51ac593c/702e4/cover.webp 1440w","type":"image/webp","sizes":"(min-width: 1440px) 1440px, 100vw"}]},"width":1440,"height":748}}}},"fields":{"slug":"/development/back-end/java/what-is-the-access-modifier"}}},{"node":{"excerpt":"문제 #91. Decode Ways A message containing letters from A-Z is being encoded to numbers using the following mapping: ‘A’ -> 1 ‘B’ -> 2 … ‘Z…","timeToRead":3,"frontmatter":{"title":"[LeetCode] #91. Decode Ways","excerpt":"디코딩 가능한 모든 경우의 수를 구해봅니다.","tags":["leet_code","algorithm","medium_level","java","string","dynamic_programming"],"date":"2020-10-27T18:09:18.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg","srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/8963f/cover.jpg 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/160a8/cover.jpg 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg 1000w","sizes":"(min-width: 1000px) 1000px, 100vw"},"sources":[{"srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/e175a/cover.webp 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/14517/cover.webp 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/7592a/cover.webp 1000w","type":"image/webp","sizes":"(min-width: 1000px) 1000px, 100vw"}]},"width":1440,"height":604.8}}}},"fields":{"slug":"/algorithm/leetcode/decode-ways"}}},{"node":{"excerpt":"문제 #79. Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of…","timeToRead":2,"frontmatter":{"title":"[LeetCode] #79. Word Search","excerpt":"주어진 단어가 2차원 배열에 연속적으로 인접하여 존재하는지 확인합니다.","tags":["leet_code","algorithm","medium_level","java","array","backtracking"],"date":"2020-10-26T11:06:56.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg","srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/8963f/cover.jpg 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/160a8/cover.jpg 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg 1000w","sizes":"(min-width: 1000px) 1000px, 100vw"},"sources":[{"srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/e175a/cover.webp 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/14517/cover.webp 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/7592a/cover.webp 1000w","type":"image/webp","sizes":"(min-width: 1000px) 1000px, 100vw"}]},"width":1440,"height":604.8}}}},"fields":{"slug":"/algorithm/leetcode/word-search"}}},{"node":{"excerpt":"문제 #78. Subsets Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain…","timeToRead":3,"frontmatter":{"title":"[LeetCode] #78. Subsets","excerpt":"중복없는 집합 요소에서 가능한 모든 조합을 구해봅니다.","tags":["leet_code","algorithm","medium_level","java","array","backtracking","bit_manipulation"],"date":"2020-10-21T20:15:36.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg","srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/8963f/cover.jpg 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/160a8/cover.jpg 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg 1000w","sizes":"(min-width: 1000px) 1000px, 100vw"},"sources":[{"srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/e175a/cover.webp 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/14517/cover.webp 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/7592a/cover.webp 1000w","type":"image/webp","sizes":"(min-width: 1000px) 1000px, 100vw"}]},"width":1440,"height":604.8}}}},"fields":{"slug":"/algorithm/leetcode/subsets"}}},{"node":{"excerpt":"문제 #64. Minimum Path Sum Given a m * n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the…","timeToRead":3,"frontmatter":{"title":"[LeetCode] #64. Minimum Path Sum","excerpt":"행렬의 좌측 상단에서 우측 하단까지의 가중치의 합이 최소인 값을 구해봅니다.","tags":["leet_code","algorithm","medium_level","java","array","dp","dynamic_programming"],"date":"2020-10-20T08:52:04.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg","srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/8963f/cover.jpg 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/160a8/cover.jpg 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg 1000w","sizes":"(min-width: 1000px) 1000px, 100vw"},"sources":[{"srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/e175a/cover.webp 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/14517/cover.webp 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/7592a/cover.webp 1000w","type":"image/webp","sizes":"(min-width: 1000px) 1000px, 100vw"}]},"width":1440,"height":604.8}}}},"fields":{"slug":"/algorithm/leetcode/minimum-path-sum"}}},{"node":{"excerpt":"문제 #73. Set Matrix Zeroes Given an m x n matrix. If an element is 0, set its entire row and column to 0. Do it in-place. Follow up: A…","timeToRead":3,"frontmatter":{"title":"[LeetCode] #73. Set Matrix Zeroes","excerpt":"행렬 원소의 값이 0이면, 해당 원소의 모든 행과 열의 원소를 0으로 설정해봅니다.","tags":["leet_code","algorithm","medium_level","java","array"],"date":"2020-10-19T08:41:14.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg","srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/8963f/cover.jpg 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/160a8/cover.jpg 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg 1000w","sizes":"(min-width: 1000px) 1000px, 100vw"},"sources":[{"srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/e175a/cover.webp 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/14517/cover.webp 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/7592a/cover.webp 1000w","type":"image/webp","sizes":"(min-width: 1000px) 1000px, 100vw"}]},"width":1440,"height":604.8}}}},"fields":{"slug":"/algorithm/leetcode/set-matrix-zeroes"}}},{"node":{"excerpt":"문제 #3. Longest Substring Without Repeating Characters Given a string s, find the length of the longest substring without repeating…","timeToRead":2,"frontmatter":{"title":"[LeetCode] #3. Longest Substring Without Repeating Characters","excerpt":"반복되지 않는 가장 긴 문자열을 찾아 봅니다.","tags":["leet_code","algorithm","medium_level","java","hash_table","two_pointers","string","sliding_window"],"date":"2020-10-14T16:52:19.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg","srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/8963f/cover.jpg 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/160a8/cover.jpg 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg 1000w","sizes":"(min-width: 1000px) 1000px, 100vw"},"sources":[{"srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/e175a/cover.webp 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/14517/cover.webp 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/7592a/cover.webp 1000w","type":"image/webp","sizes":"(min-width: 1000px) 1000px, 100vw"}]},"width":1440,"height":604.8}}}},"fields":{"slug":"/algorithm/leetcode/longest-substring-without-repeating-characters"}}},{"node":{"excerpt":"문제 #19. Remove Nth Node From End of List Given the head of a linked list, remove the nth node from the end of the list and return its head…","timeToRead":2,"frontmatter":{"title":"[LeetCode] #19. Remove Nth Node From End of List","excerpt":"한번의 순회를 통해, 뒤에서 n번째 노드를 제거해 봅니다.","tags":["leet_code","algorithm","medium_level","java","linked_list","two_pointers"],"date":"2020-10-13T16:02:49.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg","srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/8963f/cover.jpg 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/160a8/cover.jpg 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/2a492/cover.jpg 1000w","sizes":"(min-width: 1000px) 1000px, 100vw"},"sources":[{"srcSet":"/static/2ec0ede8ee2d9260970a53f04a04b8c3/e175a/cover.webp 250w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/14517/cover.webp 500w,\n/static/2ec0ede8ee2d9260970a53f04a04b8c3/7592a/cover.webp 1000w","type":"image/webp","sizes":"(min-width: 1000px) 1000px, 100vw"}]},"width":1440,"height":604.8}}}},"fields":{"slug":"/algorithm/leetcode/remove-nth-node-from-end-of-list"}}}]}},"pageContext":{"tag":"java"}},
    "staticQueryHashes": ["1144773313","288898337"]}